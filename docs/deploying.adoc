= Deploying proxies

Topologies etc

== Selecting plugins
Put the filter jars in some directory

== Providing implementations for facades



== Configuring virtual clusters

As described earlier, the _Virtual Cluster_ is the downstream representation of a Kafka Cluster.  Kafka Client connect
to the Virtual Cluster.

You must define at least one Virtual Cluster.

Let's look at how that is done by considering first a simple example.  After we will look at more advanced options
including TLS.

[source, yaml]
----
virtualClusters:
  demo:                                         # <1>
    targetCluster:
      bootstrap_servers: myprivatecluster:9092  # <2>
    clusterNetworkAddressConfigProvider:
      type: PortPerBrokerClusterNetworkAddressConfigProvider                       # <3>
      config:
        bootstrapAddress: mypublickroxylicious:9192    # <4>
----
<1> The name of the virtual cluster.
<2> The bootstrap of the (physical) Kafka Cluster.  This is the Kafka Cluster being proxied.
<3> The name of a cluster network address config provider. The built-in types are `PortPerBrokerClusterNetworkAddressConfigProvider` and `SniRoutingClusterNetworkAddressConfigProvider`.
<4> The hostname and port of the bootstrap that will be used by the Kafka Clients.  The hostname must be resolved
by the clients.

This configuration declares a virtual cluster called `demo`.  The physical Kafka Cluster being proxied is the defined
by the `targetCluster` element.  In this example, the `PortPerBroker` scheme is used by Kroxlicious to present the
virtual cluster to the clients.  Under this schema, Kroxylicious will open a port for each broker of the target cluster
with port numbers beginning at `9192` +1.  So, if the target cluster has three brokers, Kroxylicious will bind 9192 for
bootstrap and 9193-9195 inclusive to allow the clients to connect to each broker.

=== Cluster Network Address Config Providers

The Cluster Network Address Config Provider controls how the virtual cluster is presented to the network. Two
alternatives are supported: `PortPerBroker` and `SniRouting` which have different characteristics which make each
suitable for different use-cases. They are described next.

==== PortPerBroker scheme

In the `PortPerBroker` scheme, Kroxylicious automatically opens a port for each virtual cluster's bootstrap and
one port per broker of each target cluster.  So, if you have two virtual clusters, each targeting a Kafka Cluster
of three brokers, Kroxylicious will bind eight ports in total.

Kroxylicious monitors the broker topology of the target cluster at runtime. It will adjust the number of open ports
dynamically.  If another broker is added to the Kafka Cluster, Kroxylicious will automatically open a port for it.
Similarly, if a broker is removed from the Kafka Cluster, Kroxylicious will automatically close the port that was
assigned to it.

The `PortPerBroker` scheme can be used with either clear text or TLS downstream connections.

[source, yaml]
----
clusterNetworkAddressConfigProvider:
  type: PortPerBrokerClusterNetworkAddressConfigProvider
  config:
    bootstrapAddress: mycluster.kafka.com:9192                   # <1>
    brokerAddressPattern: mybroker-$(nodeId).mycluster.kafka.com # <2>
    brokerStartPort: 9193                                        # <3>
    numberOfBrokerPorts: 3                                       # <4>
    bindAddress: 192.168.0.1                                     # <5>
----
<1> The hostname and port of the bootstrap that will be used by the Kafka Clients.
<2> (Optional) The broker address pattern used to form the broker addresses.  If not defined, it defaults to the
hostname part of the `bootstrapAddress` and the port number allocated to the broker.
<3> (Optional) The starting number for broker port range. Defaults to the port of the `bootstrapAddress` plus 1.
<4> (Optional) The _maximum_ number of brokers of ports that are permitted.  Defaults to 3.
<5> (Optional) The bind address used when binding the ports. If undefined, all network interfaces will be bound.

The `brokerAddressPattern` configuration parameter understands the replacement token `$(nodeId)`. It is optional.
If present, it will be replaced by the https://kafka.apache.org/documentation/#brokerconfigs_node.id[`node.id`] (or
`broker.id`) assigned to the broker of the target cluster.

For example if your configuration looks like the above and your cluster has three brokers, your Kafka Client will receive
broker address information like this:

```
0.  `mybroker-0.mycluster.kafka.com:9193`
1.  `mybroker-1.mycluster.kafka.com:9194`
2.  `mybroker-2.mycluster.kafka.com:9194`
```

NOTE: It is a responsibility for the deployer of Kroxylicious to ensure that the bootstrap and generated broker
DNS names are resolvable and routable by the Kafka Client.

The `numberOfBrokerPorts` imposes a maximum on the number of brokers that a Kafka Cluster can have. Set this value
to be as high as the maximum number of brokers that your operational rules allow for a Kafka Cluster.

==== SniRouting scheme

In the `SniRouting` scheme, Kroxylicious uses SNI information to route traffic to either the boostrap or individual
brokers.   As this relies on SNI (Server Name Indication), the use of <<Downstream TLS>> is *required*.

With this scheme, you have the choice to share a single port across all virtual clusters, or you can assign a different
port to each.  Single port operation may have cost advantages when using load balancers of public clouds, as it allows
a single cloud provider load balancer to be shared across all virtual clusters.

[source, yaml]
----
clusterNetworkAddressConfigProvider:
  type: SniRoutingClusterNetworkAddressConfigProvider
  config:
    bootstrapAddress: mycluster.kafka.com:9192                    # <1>
    brokerAddressPattern: mybroker-$(nodeId).mycluster.kafka.com  # <2>
    bindAddress: 192.168.0.1                                      # <3>
----
<1> The hostname and port of the bootstrap that will be used by the Kafka Clients.
<2> The broker address pattern used to form the broker addresses. The `$(nodeId)` token must be present.
<3> (Optional) The bind address used when binding the port. If undefined, all network interfaces will be bound.

The `brokerAddressPattern` configuration parameters requires that the `$(nodeId)` token is present within it.
This is replaced by the https://kafka.apache.org/documentation/#brokerconfigs_node.id[`node.id`] (or `broker.id)
assigned to the broker of the target cluster.  This allows Kroxylicious to generate separate routes for each broker.

NOTE: It is a responsibility for the deployer of Kroxylicious to ensure that the bootstrap and generated broker
DNS names are resolvable and routable by the Kafka Client.

=== Transport Layer Security (TLS)

In this section we look at how to enable TLS for either the downstream and/or upstream.   Note, there is no
interdependency; it is supported to have TLS configured for the downstream and use clear text communications for the
upstream, or vice-versa.

NOTE: TLS is recommended for both upstream and downstream for production configurations.

=== Downstream TLS

Here's how to enable TLS for the downstream side. This means the Kafka Client will connect to the virtual cluster over
TLS rather than clear text.  For this, you will need to obtain a TLS certificate for the virtual cluster from your
Certificate Authority.

NOTE: When requesting the certificate ensure that the certificate will match the names of the virtual cluster's
bootstrap and broker addresses.  This may mean making use of wildcard certificates and/or Subject Alternative Names (SANs).

Kroxylicious accepts key material in PKCS12 or JKS keystore format, or PEM formatted file(s).  The following configuration
illustrates configuration with PKCS12 keystore.

[source, yaml]
----
virtualClusters:
  demo:
    tls:
        key:
          storeFile: /opt/cert/server.p12               # <1>
          storePassword:
            passwordFile: /opt/cert/store.password      # <2>
          keyPassword:
            passwordFile: /opt/cert/key.password        # <3>
          storeType: PKCS12                             # <4>
    clusterNetworkAddressConfigProvider:
      ...
----
<1> File system location of a keystore (or in the case of `PEM` format a text file containing the concatenation of the
private key, certificate, and intermediates).
<2> File system location of a file containing the key store's password.
<3> (Optional) File system location of a file containing the key's password. If omitted the key store's password is
used to decrypt the key too.
<4> (Optional) Store type. Supported types are: `PKCS12`, `JKS` and `PEM`.  Defaults to Java default key store type
which is usually `PKCS12`.

Alternatively, if your key material is in separate PEM files (private key, and certificate/intermediates), the following
configuration may be used:

[source, yaml]
----
virtualClusters:
  demo:
    tls:
        key:
          privateKeyFile: /opt/cert/server.key          # <1>
          certificateFile: /opt/cert/server.crt         # <2>
          keyPassword:
            passwordFile: /opt/cert/key.password        # <3>
    clusterNetworkAddressConfigProvider:
      ...
----
<1> File system location of the server private key.
<2> File system location of the server certificate and intermediate(s).
<3> (Optional) File system location of a file containing the key's password.

NOTE: For the private-key, https://datatracker.ietf.org/doc/html/rfc5208[PKCS-8 keys] are supported by default.
For https://datatracker.ietf.org/doc/html/rfc8017[PKCS-1 keys], https://www.bouncycastle.org/[Bouncycastle] libraries
must be added to the Kroxylicious classpath.See https://github.com/netty/netty/issues/7323 for more details.

[#_upstream_tls]
=== Upstream TLS

Here's how to enable TLS for the upstream side.This means that Kroxylicious connects to the (physical) Kafka Cluster)
over TLS.For this, your Kafka Cluster must have already been configured to use TLS.

By default, Kroxylicious inherits what it trusts from the platform it is running on and uses this to determine whether
the Kafka Cluster is trusted or not.

To support cases where trust must be overridden (such as use-cases involving the use of private CAs or self-signed
certificates), Kroxylicious accepts override trust material in PKCS12 or JKS keystore format, or PEM formatted
certificates.

The following illustrates enabling TLS, inheriting platform trust:

[source, yaml]
----
virtualClusters:
  demo:
    targetCluster:
      bootstrap_servers: myprivatecluster:9092
      tls: {}                                         <1>
      #...
----
<1> Use an empty object to enable TLS inheriting trust from the platform.

The following illustrates enabling TLS but with trust coming from a PKCS12 trust store instead of the platform:

[source, yaml]
----
virtualClusters:
  demo:
    targetCluster:
      bootstrap_servers: myprivatecluster:9092
      tls:
        trust:
          storeFile: /opt/cert/trust.p12                # <1>
          storePassword:
            passwordFile: /opt/cert/store.password      # <2>
          storeType: PKCS12                             # <3>
      #...
----
<1> File system location of a truststore (or in the case of `PEM` format a text file containing the certificates).
<2> File system location of a file containing the trust store's password.
<3> (Optional) Trust store type. Supported types are: `PKCS12`, `JKS` and `PEM`.  Defaults to Java default key store type (PKCS12).

The following illustrates connection to physical cluster using TLS client authentication (aka Mutual TLS).

[source, yaml]
----
virtualClusters:
  demo:
    targetCluster:
      bootstrap_servers: myprivatecluster:9092
      tls:
        key:
          privateKeyFile: /opt/cert/client.key
          certificateFile: /opt/cert/client.cert
        trust:
          storeFile: /opt/cert/client/server.cer
          storeType: PEM
----
It is also possible to disable trust so that Kroxylicious will connect to any Kafka Cluster regardless of its certificate
validity.

WARNING: This option is not recommended for production use.

[source, yaml]
----
virtualClusters:
  demo:
    targetCluster:
      bootstrap_servers: myprivatecluster:9092
      tls:
        trust:
          insecure: true                                # <1>
      #...
----
<1> Enables insecure TLS.

YAML
Proxy level configuration

== Configuring proxy plugins
Filter level configuration
